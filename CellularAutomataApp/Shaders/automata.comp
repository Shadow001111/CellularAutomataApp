#version 460 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(r8ui, binding = 0) readonly uniform uimage2D currentWorld;
layout(r8ui, binding = 1) writeonly uniform uimage2D nextWorld;

uniform int gridWidth;
uniform int gridHeight;

const int neighbourSearchRange = 5;
// const int statesCount = 2; // alive, dead
const bool countTheCenterCell = true;
const uvec2 stableRange = uvec2(34, 58);
const uvec2 birthRange = uvec2(34, 45);

// TODO: Add more states. Add weights.
// TODO: Try removing center cell check condition in countNeighbours method. 

uint countNeighbours(ivec2 pos)
{
    uint count = 0;
    for (int y = -neighbourSearchRange; y <= neighbourSearchRange; y++)
    {
        for (int x = -neighbourSearchRange; x <= neighbourSearchRange; x++)
        {
            if (x == 0 && y == 0) continue; // skip self
            ivec2 neighborPos = pos + ivec2(x, y);
            // Wrap around edges
            neighborPos = ivec2((neighborPos.x + gridWidth) % gridWidth, (neighborPos.y + gridHeight) % gridHeight);
            count += imageLoad(currentWorld, neighborPos).r;
        }
    }
    return count;
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    uint cell = imageLoad(currentWorld, pos).r;

    uint neighbours = countNeighbours(pos);
    if (countTheCenterCell)
    {
        neighbours += cell;
    }

    uint nextCell = 0;
    if (neighbours >= birthRange.x && neighbours <= birthRange.y)
    {
        nextCell = 1;
    }
    else if (neighbours >= stableRange.x && neighbours <= stableRange.y)
    {
        nextCell = cell;
    }

    imageStore(nextWorld, pos, uvec4(nextCell, 0, 0, 0));
}