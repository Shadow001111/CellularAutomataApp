#version 460 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(r8ui, binding = 0) readonly uniform uimage2D currentWorld;
layout(r8ui, binding = 1) writeonly uniform uimage2D nextWorld;

uniform int gridWidth;
uniform int gridHeight;

uniform int neighborSearchRange;
// const int statesCount = 2; // alive, dead
uniform uvec2 stableRange;
uniform uvec2 birthRange;

layout(std430, binding = 2) buffer KernelBuffer
{
    float kernel[];
};

// CONWAY: 1; false; (2, 3); (3, 3)
// BUGS: 5; true; (34, 58); (34, 45)

float getNeighborsSum(ivec2 pos)
{
    float sum = 0.0;
    uint index = 0;
    for (int y = -neighborSearchRange; y <= neighborSearchRange; y++)
    {
        for (int x = -neighborSearchRange; x <= neighborSearchRange; x++)
        {
            ivec2 neighborPos = pos + ivec2(x, y);
            neighborPos = ivec2((neighborPos.x + gridWidth) % gridWidth, (neighborPos.y + gridHeight) % gridHeight);

            uint value = imageLoad(currentWorld, neighborPos).r;
            sum += float(value) * kernel[index];
            index++;
        }
    }
    return sum;
}

void main()
{   
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    uint cell = imageLoad(currentWorld, pos).r;

    float neighborsSum = getNeighborsSum(pos);

    uint nextCell = 0;
    if (neighborsSum >= birthRange.x && neighborsSum <= birthRange.y)
    {
        nextCell = 1;
    }
    else if (neighborsSum >= stableRange.x && neighborsSum <= stableRange.y)
    {
        nextCell = cell;
    }

    imageStore(nextWorld, pos, uvec4(nextCell, 0, 0, 0));
}