#version 460 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(r8ui, binding = 0) readonly uniform uimage2D currentWorld;
layout(r8ui, binding = 1) writeonly uniform uimage2D nextWorld;

uniform int gridWidth;
uniform int gridHeight;

uniform int neighborSearchRange;
// const int statesCount = 2; // alive, dead
uniform bool countTheCenterCell;
uniform uvec2 stableRange;
uniform uvec2 birthRange;

// CONWAY: 1; false; (2, 3); (3, 3)
// BUGS: 1; true; (34, 58); (34, 45)

// TODO: Add more states. Add weights.
// TODO: Try removing center cell check condition in countNeighbors method. 

uint countNeighbors(ivec2 pos)
{
    uint count = 0;
    for (int y = -neighborSearchRange; y <= neighborSearchRange; y++)
    {
        for (int x = -neighborSearchRange; x <= neighborSearchRange; x++)
        {
            if (x == 0 && y == 0) continue; // skip self
            ivec2 neighborPos = pos + ivec2(x, y);
            // Wrap around edges
            neighborPos = ivec2((neighborPos.x + gridWidth) % gridWidth, (neighborPos.y + gridHeight) % gridHeight);
            count += imageLoad(currentWorld, neighborPos).r;
        }
    }
    return count;
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    uint cell = imageLoad(currentWorld, pos).r;

    uint neighbors = countNeighbors(pos);
    if (countTheCenterCell)
    {
        neighbors += cell;
    }

    uint nextCell = 0;
    if (neighbors >= birthRange.x && neighbors <= birthRange.y)
    {
        nextCell = 1;
    }
    else if (neighbors >= stableRange.x && neighbors <= stableRange.y)
    {
        nextCell = cell;
    }

    imageStore(nextWorld, pos, uvec4(nextCell, 0, 0, 0));
}